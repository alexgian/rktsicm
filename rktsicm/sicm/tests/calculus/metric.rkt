#lang racket/base

(require rackunit
         "../../main.rkt"
         "../helper.rkt"
         )

(provide the-tests)
(define the-tests
  (test-suite
   "calculus/metric"
   ;;(set! *divide-out-terms* #f)
   ;;(set! *factoring* #t)
   (test-case
    "Example: natural metric on a sphere of radius R"
    (define 2-sphere R2-rect)
    (define-coordinates (up theta phi) 2-sphere)
    (define ((g-sphere R) u v)
      (* (square R)
         (+ (* (dtheta u) (dtheta v))
            (* (compose (square sin) theta)
               (dphi u)
               (dphi v)))))

    (define u (literal-vector-field 'u 2-sphere))
    (define v (literal-vector-field 'v 2-sphere))
    (check-simplified? (((g-sphere 'R) u v)
                        ((2-sphere '->point) (up 'theta0 'phi0)))
                       '(* (+ (* (v^0 (up theta0 phi0))
                                 (u^0 (up theta0 phi0)))
                              (* (expt (sin theta0) 2)
                                 (v^1 (up theta0 phi0))
                                 (u^1 (up theta0 phi0))))
                           (expt R 2))))
   (test-case
    "Example: Lorentz metric on R^4"
    (define SR R4-rect)
    (define-coordinates (up t x y z) SR)
    (define ((g-Lorentz c) u v)
      (+ (* (dx u) (dx v))
         (* (dy u) (dy v))
         (* (dz u) (dz v))
         (* -1 (square c) (dt u) (dt v))))
    (void "no actual test ..."))
   (test-case
    "Example: general metric on R^2"
    (define-coordinates (up x y) R2-rect)
    (define R2-basis (coordinate-system->basis R2-rect))
    (define ((g-R2 g_00 g_01 g_11) u v)
      (+ (* g_00 (dx u) (dx v))
         (* g_01 (+ (* (dx u) (dy v)) (* (dy u) (dx v))))
         (* g_11 (dy u) (dy v))))
    (check-simplified? (((g-R2 'a 'b 'c)
                         (literal-vector-field 'u R2-rect)
                         (literal-vector-field 'v R2-rect))
                        ((R2-rect '->point) (up 'x0 'y0)))
                       '(+ (* (u^0 (up x0 y0)) (v^0 (up x0 y0)) a)
                           (* (+ (* (v^0 (up x0 y0)) (u^1 (up x0 y0)))
                                 (* (u^0 (up x0 y0)) (v^1 (up x0 y0))))
                              b)
                           (* (v^1 (up x0 y0)) (u^1 (up x0 y0)) c))))
   (check-simplified? ((coordinate-system->metric-components R3-spherical) (up 'r 'theta 'phi))
                      '(down (down 1 0 0)
                             (down 0 (expt r 2) 0)
                             (down 0 0 (* (expt r 2) (expt (sin theta) 2)))))
   (check-simplified? (s:map/r (lambda (v1)
                                 (s:map/r (lambda (v2)
                                            (((coordinate-system->metric R3-spherical) v1 v2)
                                             ((point R3-spherical) (up 'r 'theta 'phi))))
                                          (coordinate-system->vector-basis R3-spherical)))
                               (coordinate-system->vector-basis R3-spherical))
                      '(down (down 1 0 0)
                             (down 0 (expt r 2) 0)
                             (down 0 0 (* (expt r 2) (expt (sin theta) 2)))))
   (check-simplified? (s:map/r (lambda (w1)
                                 (s:map/r (lambda (w2)
                                            (((coordinate-system->inverse-metric R3-spherical) w1 w2)
                                             ((point R3-spherical) (up 'r 'theta 'phi))))
                                          (coordinate-system->1form-basis R3-spherical)))
                               (coordinate-system->1form-basis R3-spherical))
                      '(up (up 1 0 0)
                           (up 0 (/ 1 (expt r 2)) 0)
                           (up 0 0 (/ 1 (* (expt r 2) (expt (sin theta) 2))))))
   (check-simplified? (((literal-metric 'g R3-rect)
                        (literal-vector-field 'u R3-rect)
                        (literal-vector-field 'v R3-rect))
                       ((R3-rect '->point) (up 'x0 'y0 'z0)))
                      '(+ (* (v^0 (up x0 y0 z0)) (u^0 (up x0 y0 z0)) (g_00 (up x0 y0 z0)))
                          (* (v^0 (up x0 y0 z0)) (g_01 (up x0 y0 z0)) (u^1 (up x0 y0 z0)))
                          (* (v^0 (up x0 y0 z0)) (g_02 (up x0 y0 z0)) (u^2 (up x0 y0 z0)))
                          (* (u^0 (up x0 y0 z0)) (v^1 (up x0 y0 z0)) (g_01 (up x0 y0 z0)))
                          (* (u^0 (up x0 y0 z0)) (v^2 (up x0 y0 z0)) (g_02 (up x0 y0 z0)))
                          (* (v^1 (up x0 y0 z0)) (u^1 (up x0 y0 z0)) (g_11 (up x0 y0 z0)))
                          (* (v^1 (up x0 y0 z0)) (g_12 (up x0 y0 z0)) (u^2 (up x0 y0 z0)))
                          (* (v^2 (up x0 y0 z0)) (u^1 (up x0 y0 z0)) (g_12 (up x0 y0 z0)))
                          (* (v^2 (up x0 y0 z0)) (u^2 (up x0 y0 z0)) (g_22 (up x0 y0 z0)))))
   (test-case
    ""
    (define-coordinates (up x y) R2-rect)
    (define R2-basis (coordinate-system->basis R2-rect))
    (define ((g-R2 g_00 g_01 g_11) u v)
      (+ (* g_00 (dx u) (dx v))
         (* g_01 (+ (* (dx u) (dy v)) (* (dy u) (dx v))))
         (* g_11 (dy u) (dy v))))
    (check-simplified? (((metric:invert (g-R2 'a 'b 'c) R2-basis)
                         (literal-1form-field 'omega R2-rect)
                         (literal-1form-field 'theta R2-rect))
                        ((R2-rect '->point) (up 'x0 'y0)))
                       '(/ (+ (* a (theta_1 (up x0 y0)) (omega_1 (up x0 y0)))
                              (* -1 b (theta_1 (up x0 y0)) (omega_0 (up x0 y0)))
                              (* -1 b (omega_1 (up x0 y0)) (theta_0 (up x0 y0)))
                              (* c (omega_0 (up x0 y0)) (theta_0 (up x0 y0))))
                           (+ (* a c) (* -1 (expt b 2)))))
    ;;; Test of inversion
    (check-simplified? (let* ((g (g-R2 'a 'b 'c))
                              (gi (metric:invert g R2-basis))
                              (vector-basis (list d/dx d/dy))
                              (dual-basis (list dx dy))
                              (m ((R2-rect '->point) (up 'x0 'y0))))
                         (matrix:generate 2 2
                                          (lambda (i k)
                                            (sigma (lambda (j)
                                                     (* ((gi (ref dual-basis i) (ref dual-basis j)) m)
                                                        ((g  (ref vector-basis j) (ref vector-basis k)) m)))
                                                   0 1))))
                       '(matrix-by-rows (list 1 0) (list 0 1)))
    (check-simplified? ((((lower (g-R2 'a 'b 'c))
                          (literal-vector-field 'v R2-rect))
                         (literal-vector-field 'w R2-rect))
                        ((R2-rect '->point) (up 'x0 'y0)))
                       '(+ (* a (v^0 (up x0 y0)) (w^0 (up x0 y0)))
                           (* b (v^0 (up x0 y0)) (w^1 (up x0 y0)))
                           (* b (v^1 (up x0 y0)) (w^0 (up x0 y0)))
                           (* c (v^1 (up x0 y0)) (w^1 (up x0 y0)))))
    (check-simplified? ((((raise (g-R2 'a 'b 'c) R2-basis)
                          ((lower (g-R2 'a 'b 'c)) (literal-vector-field 'v R2-rect)))
                         (compose (literal-function 'w (-> (UP Real Real) Real))
                                  (R2-rect '->coords)))
                        ((R2-rect '->point) (up 'x0 'y0)))
                       '(+ (* (v^0 (up x0 y0)) (((partial 0) w) (up x0 y0)))
                           (* (v^1 (up x0 y0)) (((partial 1) w) (up x0 y0)))))
    (check-simplified? ((((sharpen (g-R2 'a 'b 'c) R2-basis ((R2-rect '->point) (up 'x0 'y0)))
                          ((lower (g-R2 'a 'b 'c)) (literal-vector-field 'v R2-rect)))
                         (compose (literal-function 'w (-> (UP Real Real) Real))
                                  (R2-rect '->coords)))
                        ((R2-rect '->point) (up 'x0 'y0)))
                       '(+ (* (v^0 (up x0 y0)) (((partial 0) w) (up x0 y0)))
                           (* (v^1 (up x0 y0)) (((partial 1) w) (up x0 y0))))))
   ))

(module+ test
  (require rackunit/text-ui)
  (run-tests the-tests))