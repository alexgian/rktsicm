#lang racket/base

(require rackunit
         "../../main.rkt"
         "../helper.rkt"
         )

(define the-tests
  (test-suite
   "calculus/Lie"
   (test-case
    "R3"
    (define-coordinates (up x y z) R3-rect)
    (define R3-rect-point ((R3-rect '->point) (up 'x0 'y0 'z0)))
    (define-coordinates (up r theta zeta) R3-cyl)
    (define R3-cyl-point ((R3-cyl '->point) (up 'r0 'theta0 'zeta0)))
    (define w (literal-1form-field 'w R3-rect))
    (define u (literal-1form-field 'u R3-rect))
    (define v (literal-1form-field 'v R3-rect))
    (define X (literal-vector-field 'X R3-rect))
    (define Y (literal-vector-field 'Y R3-rect))
    (define Z (literal-vector-field 'Z R3-rect))
    (define W (literal-vector-field 'W R3-rect))
    (define f (literal-scalar-field 'f R3-rect))
    (void (clear-arguments)
          (suppress-arguments (list '(up x0 y0 z0))))
    (check-simplified? ((((Lie-derivative X) w) Y) R3-rect-point)
                       '(+ (* ((partial 0) w_0) X^0 Y^0)
                           (* ((partial 0) w_1) X^0 Y^1)
                           (* ((partial 0) w_2) X^0 Y^2)
                           (* ((partial 1) w_0) X^1 Y^0)
                           (* ((partial 1) w_1) X^1 Y^1)
                           (* ((partial 1) w_2) X^1 Y^2)
                           (* ((partial 2) w_0) X^2 Y^0)
                           (* ((partial 2) w_1) X^2 Y^1)
                           (* ((partial 2) w_2) X^2 Y^2)
                           (* ((partial 0) X^0) w_0 Y^0)
                           (* ((partial 1) X^0) w_0 Y^1)
                           (* ((partial 2) X^0) w_0 Y^2)
                           (* ((partial 0) X^1) w_1 Y^0)
                           (* ((partial 1) X^1) w_1 Y^1)
                           (* ((partial 2) X^1) w_1 Y^2)
                           (* ((partial 0) X^2) Y^0 w_2)
                           (* ((partial 1) X^2) Y^1 w_2)
                           (* ((partial 2) X^2) w_2 Y^2)))
    (check-simplified? ((- ((d ((Lie-derivative X) f)) Y)
                           (((Lie-derivative X) (d f)) Y) )
                        R3-rect-point)
                       0)
    (check-simplified? ((- ((d ((Lie-derivative X) w)) Y Z)
                           (((Lie-derivative X) (d w)) Y Z) )
                        ((R3-rect '->point) (up 'x^0 'y^0 'z^0)))
                       0))
   (test-case
    "R2"
    (define-coordinates (up x y) R2-rect)
    (define R2-rect-point ((R2-rect '->point) (up 'x0 'y0)))
    (define X (literal-vector-field 'X R2-rect))
    (define Y (literal-vector-field 'Y R2-rect))
    (define f (literal-scalar-field 'f R2-rect))
    (void (clear-arguments)
          (suppress-arguments (list '(up x0 y0))))
    (check-simplified? ((((Lie-derivative X) Y) f) R2-rect-point)
                       '(+ (* ((partial 0) Y^0) X^0 ((partial 0) f))
                           (* ((partial 0) Y^1) X^0 ((partial 1) f))
                           (* ((partial 1) Y^0) X^1 ((partial 0) f))
                           (* ((partial 1) Y^1) X^1 ((partial 1) f))
                           (* -1 ((partial 0) X^0) Y^0 ((partial 0) f))
                           (* -1 ((partial 0) X^1) Y^0 ((partial 1) f))
                           (* -1 ((partial 1) X^0) ((partial 0) f) Y^1)
                           (* -1 ((partial 1) X^1) Y^1 ((partial 1) f))))
    (define ((((Lie-test V) Y) f) x)
      (let ((I (chart R2-rect)))
        (define (g t)
          (- ((compose (Y f) (point R2-rect))
              ((+ I (* t (V I))) x))
             ((Y (compose f
                          (point R2-rect)
                          (+ I (* t (V I)))))
              x)))
        ((D g) 0)))
    (check-simplified? (- ((((Lie-test X) Y) f) R2-rect-point)
                          ((((Lie-derivative X) Y) f) R2-rect-point))
                       0))
   (test-case
    "Lie derivative satisfies extended Leibnitz rule"
    (define V (literal-vector-field 'V R2-rect))
    (define Y (literal-vector-field 'Y R2-rect))
    (define q_0 (up 'q_x 'q_y))
    (define m ((R2-rect '->point) q_0))
    (define f (literal-manifold-function 'f R2-rect))
    (define e_0 (literal-vector-field 'e_0 R2-rect))
    (define e_1 (literal-vector-field 'e_1 R2-rect))
    (define vector-basis (down e_0 e_1))
    (define 1form-basis (vector-basis->dual (down e_0 e_1) R2-rect))
    (define basis (make-basis vector-basis 1form-basis))
    (define Y^i (1form-basis Y))
    (check-simplified? ((- (((Lie-derivative V) Y) f)
                           (+ (* (s:map/r (Lie-derivative V) Y^i) (vector-basis f))
                              (* Y^i ((s:map/r (Lie-derivative V) vector-basis) f))))
                        m)
                       0)
    ;;; Computation of Lie derivatives by difference quotient.
    (define X (literal-vector-field 'X R2-rect))
    (define m_0 ((R2-rect '->point) q_0))
    (define ((q coords)  t)
      (+ coords
         (* t
            ((X (R2-rect '->coords))
             ((R2-rect '->point) coords)))))
    (define (gamma initial-point)
      (compose (R2-rect '->point)
               (q ((R2-rect '->coords) initial-point))))
    (define ((phi^X t) point)
      ((gamma point) t))
    (check-simplified? ((D (lambda (t)
                             (- ((Y f) ((phi^X t) m_0))
                                ((Y (compose f (phi^X t))) m_0))))
                        0)
                       '(+ (* -1 (((partial 1) X^0) (up q_x q_y)) (Y^1 (up q_x q_y)) (((partial 0) f) (up q_x q_y)))
                           (* -1 (Y^1 (up q_x q_y)) (((partial 1) X^1) (up q_x q_y)) (((partial 1) f) (up q_x q_y)))
                           (* (((partial 1) Y^0) (up q_x q_y)) (((partial 0) f) (up q_x q_y)) (X^1 (up q_x q_y)))
                           (* (((partial 0) f) (up q_x q_y)) (((partial 0) Y^0) (up q_x q_y)) (X^0 (up q_x q_y)))
                           (* -1 (((partial 0) f) (up q_x q_y)) (((partial 0) X^0) (up q_x q_y)) (Y^0 (up q_x q_y)))
                           (* (((partial 1) Y^1) (up q_x q_y)) (((partial 1) f) (up q_x q_y)) (X^1 (up q_x q_y)))
                           (* (((partial 1) f) (up q_x q_y)) (((partial 0) Y^1) (up q_x q_y)) (X^0 (up q_x q_y)))
                           (* -1 (((partial 1) f) (up q_x q_y)) (((partial 0) X^1) (up q_x q_y)) (Y^0 (up q_x q_y)))))
    (check-simplified? ((((Lie-derivative X) Y) f) m_0)
                       '(+ (* -1 (((partial 1) X^0) (up q_x q_y)) (Y^1 (up q_x q_y)) (((partial 0) f) (up q_x q_y)))
                           (* -1 (Y^1 (up q_x q_y)) (((partial 1) X^1) (up q_x q_y)) (((partial 1) f) (up q_x q_y)))
                           (* (((partial 1) Y^0) (up q_x q_y)) (((partial 0) f) (up q_x q_y)) (X^1 (up q_x q_y)))
                           (* (((partial 0) f) (up q_x q_y)) (((partial 0) Y^0) (up q_x q_y)) (X^0 (up q_x q_y)))
                           (* -1 (((partial 0) f) (up q_x q_y)) (((partial 0) X^0) (up q_x q_y)) (Y^0 (up q_x q_y)))
                           (* (((partial 1) Y^1) (up q_x q_y)) (((partial 1) f) (up q_x q_y)) (X^1 (up q_x q_y)))
                           (* (((partial 1) f) (up q_x q_y)) (((partial 0) Y^1) (up q_x q_y)) (X^0 (up q_x q_y)))
                           (* -1 (((partial 1) f) (up q_x q_y)) (((partial 0) X^1) (up q_x q_y)) (Y^0 (up q_x q_y)))))
    (check-simplified? (- ((D (lambda (t)
                                (- ((Y f) ((phi^X t) m_0))
                                   ((Y (compose f (phi^X t))) m_0))))
                           0)
                          ((((Lie-derivative X) Y) f) m_0))
                       0)
    (check-simplified? (- ((D (lambda (t)
                                (- ((Y f) ((phi^X t) m_0)) 
                                   ((((pushforward-vector (phi^X t) (phi^X (- t)))
                                      Y)
                                     f)
                                    ((phi^X t) m_0)))))
                           0)
                          ((((Lie-derivative X) Y) f) m_0))
                       0)
    (check-simplified? (- ((D (lambda (t)
                                ((((pushforward-vector (phi^X (- t)) (phi^X t))
                                   Y)
                                  f)
                                 m_0)))
                           0)
                          ((((Lie-derivative X) Y) f) m_0))
                       0))
   (test-case
    "Verifying equation 0.184"
    (define m ((R2-rect '->point) (up 'x 'y)))
    (define V (literal-vector-field 'V R2-rect))
    (define Y (literal-vector-field 'Y R2-rect))
    (define f (literal-manifold-function  'f R2-rect))
    (define e_0 (literal-vector-field 'e_0 R2-rect))
    (define e_1 (literal-vector-field 'e_1 R2-rect))
    (define vector-basis (down e_0 e_1))
    (define 1form-basis (vector-basis->dual (down e_0 e_1) R2-rect))
    (define e^0 (ref 1form-basis 0))
    (define e^1 (ref 1form-basis 1))
    (define basis (make-basis vector-basis 1form-basis))
    (define (Delta^i_j v) (1form-basis (s:map/r (Lie-derivative v) vector-basis)))
    (check-simplified? ((- (((Lie-derivative V) Y) f)
                           (* (vector-basis f)
                              (+ (V (1form-basis Y))
                                 (* (1form-basis Y) (Delta^i_j V)))))
                        m)
                       0)
    ;;; Indeed, a painful detail:
    (check-simplified? ((- (* (1form-basis Y) ((s:map/r (Lie-derivative V) vector-basis) f))
                           (* (1form-basis Y) (Delta^i_j V) (vector-basis f)))
                        m)
                       0)
    ;;; Even simpler
    (check-simplified? ((- (* ((s:map/r (Lie-derivative V) vector-basis) f))
                           (* (Delta^i_j V) (vector-basis f)))
                        m)
                       '(down 0 0)))
   ))

(module+ test
  (require rackunit/text-ui)
  (run-tests the-tests))